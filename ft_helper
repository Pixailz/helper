#!/usr/bin/env python3

from pprint import pprint
import re
import os

"""
class SrcMakefile():
	def __init__(self):
		pass

class Proto():
	def __init__(self, src_files, header):
		self.c_files = src_files
		self.header = header
"""

class RegexFinder():
	def __init__(self, makefile_var):
		self.compile_all_regex(makefile_var)

	def compile_all_regex(self, makefile_var):
		options = {
			"flags": re.MULTILINE | re.ASCII
		}
		self.re_function_infile = re.compile(
			r'^\w+\*?\s+\*?\w+\*?\s+\*?\w+\(.*\)$|' +
			r'^\w+\*?\s+\*?\w+?\(.*\)$',
			**options
		)
		self.re_c_files = re.compile(r'.*\.c', re.ASCII)
		self.re_h_files = re.compile(r'.*\.h', re.ASCII)
		self.re_get_header = re.compile(r'^#include "(.*)"')
		self.re_get_first_src_makefile = re.compile(
			r'^' + re.escape(makefile_var) + r'\s+:=.*\\?$'
			, **options
		)
		self.re_get_last_src_makefile = re.compile(
			r'^\s+\w+.*\.c$',
			**options
		)
		self.re_proto_type_len = re.compile(
			r'^(\w+\*?\s+|\w+\*?\s+\*?\w+\*?\s+)\*?\w*\(.*\)$',
			**options
		)

class	ft_helper():
	def	__init__(self, makefile, makefile_var, header, src_folder):
		self.cwd = os.getcwd()
		self.makefile = makefile
		self.makefile_var = makefile_var
		self.header =  header
		self.header_begin = \
			"/* ########################################################################## */\n" \
			"/* FILES */\n" \
			"/* ##### */\n"
		self.header_end = \
			"/* ########################################################################## */"
		self.src_folder = os.path.join(self.cwd, src_folder)
		self.regex = RegexFinder(makefile_var)
		self.get_files()
		self.get_function_all_files()
		self.replace_proto_header()
		self.replace_src_makefile()

	def	get_files(self):
		self.files = list()
		for (dirpath, dirname, filename) in os.walk(self.src_folder):
			for file in filename:
				self.files.append(os.path.join(dirpath, file))
		self.files = sorted(self.files)
		self.c_files = { f: list()
			for f in self.files if self.regex.re_c_files.findall(f)
		}

	def	get_function(self, filename, function):
		file_str = str()
		with open(filename, 'r') as f:
			file_str = f.read()
		# header = self.regex.re_get_header.findall(file_str)
		# if len(header) == 0:
		# 	function.append(None)
		# else:
		# 	function.extend(header)
		function_list = sorted(self.regex.re_function_infile.findall(file_str))
		function.extend(function_list)

	def get_function_all_files(self):
		for filename, function in self.c_files.items():
			self.get_function(filename, function)

	def	get_src_makefile_multiple(self, file_str):
		src_makefile_str = str()
		first_src = self.regex.re_get_first_src_makefile.findall(file_str)[0]
		nb_tab = first_src.count('\t')
		first_src_path = list(self.c_files.keys())[0]
		last_src_path = list(self.c_files.keys())[-1]
		src_makefile_str += 'SRC_C' + str('\t' * nb_tab) + ":= " + \
			first_src_path.replace(self.src_folder + '/', '') + " \\\n"
		c_files = dict(self.c_files)
		del(c_files[first_src_path])
		for file_path in c_files:
			if file_path != last_src_path:
				src_makefile_str += str('\t' * (nb_tab + 1)) + "   " + \
				file_path.replace(self.src_folder + '/', '') + ' \\\n'
			else:
				src_makefile_str += str('\t' * (nb_tab + 1)) + "   " + \
				file_path.replace(self.src_folder + '/', '')
		return(src_makefile_str)

	def	get_src_makefile_one(self, file_str):
		src_makefile_str = str()
		first_src = self.regex.re_get_first_src_makefile.findall(file_str)[0]
		nb_tab = first_src.count('\t')
		first_src_path = list(self.c_files.keys())[0]
		src_makefile_str += 'SRC_C' + str('\t' * nb_tab) + ":= " + \
			first_src_path.replace(self.src_folder + '/', '')
		return(src_makefile_str)

	def	replace_src_makefile(self):
		with open(self.makefile, 'r') as f:
			file_str = f.read()
		self.have_backslash = \
					self.regex.re_get_first_src_makefile.findall(file_str)[0]
		if len(self.c_files) == 1:
			to_replace = self.get_src_makefile_one(file_str)
		else:
			to_replace = self.get_src_makefile_multiple(file_str)
		if self.have_backslash[-1] == '\\':
			pattern = re.escape(self.have_backslash) + \
				r'.*' + \
				self.regex.re_get_last_src_makefile.findall(file_str)[0]
			file_str_replace = file_str.replace(
				re.findall(pattern, file_str, flags=re.DOTALL)[0],
				to_replace
			)
		else:
			pattern = re.escape(self.have_backslash)
			file_str_replace = file_str.replace(
				re.findall(pattern, file_str, flags=re.DOTALL)[0],
				to_replace
			)
		with open(self.makefile, 'w') as f:
			f.write(file_str_replace)

	def	get_proto_nb_tab(self):
		max_len = 0
		for functions in self.c_files.values():
			for function in functions:
				tmp_len = len(self.regex.re_proto_type_len.findall(function)[0])
				tmp_len = (tmp_len - 1) + (4 - (tmp_len -1) % 4)
				if tmp_len > max_len:
					max_len = tmp_len
		return (max_len)

	def	arrange_proto(self, function, nb_tab):
		current_len = len(self.regex.re_proto_type_len.findall(function)[0])
		current_tab = int(((current_len - 1) + (4 - (current_len -1) % 4)) / 4)
		tab_left = int((nb_tab + (4 - nb_tab % 4)) / 4) - current_tab
		function = function.replace('\t', '\t' * tab_left)
		return (function)

	def	get_proto(self, file_str):
		proto_str = str()
		proto_str += self.header_begin + '\n'
		nb_tab = self.get_proto_nb_tab()
		for file_path, functions in self.c_files.items():
			proto_str += "// " + file_path.replace(self.src_folder + '/', '') + '\n'
			for function in functions:
				function = self.arrange_proto(function, nb_tab)
				proto_str += function + ';\n'
			proto_str += '\n'
		proto_str += self.header_end
		return (proto_str)

	def	replace_proto_header(self):
		with open(self.header, 'r') as f:
			file_str = f.read()
		to_replace = self.get_proto(file_str)
		pattern = re.escape(self.header_begin) + r'.*' + re.escape(self.header_end)
		from_replace = re.findall(pattern, file_str, flags=re.DOTALL)
		if len(from_replace) == 0:
			print("Error: header_begin or header_end not found")
			return
		file_str_replace = file_str.replace(
			from_replace[0],
			to_replace
		)
		with open(self.header, 'w') as f:
			f.write(file_str_replace)

	def	debug_formated_data(self):
		for file, options in self.c_files.items():
			print(file)
			for function in options:
				print(' ' * 4 + function.expandtabs(12))
			print('\n')

	def	debug_raw_data(self):
		print(self.c_files)

if __name__ == "__main__":
	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_CHK",
		"header":		"include/libft_check.h",
		"src_folder":	"src/check"
	}
	ft_libft_check = ft_helper(**config)
	exit()

	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_INP",
		"header":		"include/libft_input.h",
		"src_folder":	"src/input"
	}
	ft_libft_input = ft_helper(**config)

	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_INT",
		"header":		"include/libft_integer.h",
		"src_folder":	"src/integer"
	}
	ft_libft_integer = ft_helper(**config)

	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_LST",
		"header":		"include/libft_list.h",
		"src_folder":	"src/list"
	}
	ft_libft_list = ft_helper(**config)

	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_MEM",
		"header":		"include/libft_memory.h",
		"src_folder":	"src/memory"
	}
	ft_libft_memory = ft_helper(**config)

	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_PRT",
		"header":		"include/libft_print.h",
		"src_folder":	"src/print"
	}
	ft_libft_print = ft_helper(**config)

	config = {
		"makefile":		"Makefile",
		"makefile_var":	"SRC_STR",
		"header":		"include/libft_string.h",
		"src_folder":	"src/string"
	}
	ft_libft_string = ft_helper(**config)
